# 3.5 Nested if Statements

We have **see**n（了解） that we can use `if` **statement**s（语句） to **choose**（选择） between two **alternative**s（二择一选项）. **Frequently**（频繁地；经常地）, **however**（然而）, we want to **choose** from among（在 ... 之中） more than two **possibilities**（原形 possibility，可能性）.

## Example 1

If we want to write a statement **based on**（基于） the **sign**（符号） of a **variable**（变量） `x`, we could write three `if` **statements**.

```java
if (x < 0)
     System.out.println("value is negative");
if (x > 0)
     System.out.println("value is positive");
if (x == 0)
     System.out.println("value is zero");
```

For any **value**（值） of `x`, this **solution**（解决方法） **involve**s（包含） three **test**s（测试）. We can **increase**（增加） the **efficiency**（效率） of the **code**（代码） by **nest**ing（嵌套） the **statement**s. This **involves** placing one `if` statement **within**（在...里面） **another**（另一个） **as shown**（如...所示） in the **next**（下一个） example.

## Example 2

This **improve**s（改进） the **efficiency** of the **code** in Example 1.

```java
if (x < 0)
   System.out.println("value is negative");
else
   if (x > 0)
      System.out.println("value is positive");
   else
      System.out.println("value is zero");
```
 
Now, **if**(如果) `x` is **negative**(负的), only one **test** is **perform**ed(执行) **while**(而) **if** `x` is **positive**(正的) or **zero**(0), only two **test**s are **perform**ed. In no **case**(情况) is it **necessary**(必要的) to **perform** three **test**s.
 
In the **next** example **nest**ing is used in a **slightly**(稍微) more **complex**(复杂) **way**(方式).

## Example 3

The `if` **statement** shown **below**(在下面) **efficiently**(高效率地) **determine**s(决定) the **largest**(最大的) **among**(在...之中) three **value**s `x`, `y`, and `z` and **assign**s(赋值) this **value** to `largest`.

```java
if (x >= y)
   // y eliminated(被排除) - largest must be either x or z
   if (x >= z)
      largest = x;
   else
      largest = z;
else 
   // x eliminated - largest must be either y or z
   if (y >= z)
      largest = y;
   else
      largest = Z;
```
      
There are many other **way**s that we could **determine** the largest of three **value**s but the one shown here **involve**s the **least**(最少的) work. 

In the examples that we have shown **so far**(迄今为止), we have been **follow**ing(遵循) the same **indentation**(缩进) **pattern**(模式) that we **introduce**d(介绍) at the beginning of this chapter, **align**ing(对齐) **corresponding**(对应的) `if`'s and `else`'s and **indent**ing two **space**s(空格) past them for **statement**s **nest**ed inside the `if`. If we have a long **sequence**(序列) of **nest**ed `if` **statement**s, the **resulting**(结果的) **indentation** can become **excessive**(过度的, 过多的), **leaving**(leave 留给) us little **room**(空间) on a line for our **statement**s. To **overcome**(克服) this, we sometimes **vary**(改变) our indentation **pattern**.

## Example 4

This **statement** prints a **comment**(评论) that **depends on**(依赖) the **value** of the `char` variable **grade**(成绩).

```java
if (grade =='A')
   System.out.println("Excellent");
else if (grade == 'B')
   System.out.println("Good");
else if (grade == 'C')
   System.out.println("Average");
else if (grade == 'D')
   System.out.println("Fair");
else if (grade == 'E')
   System.out.println("Poor");
else
   System.out.println("Invalid grade");
```
   
**As well as**(不但…而且) noting the indentation style, **note**(注意) that the **last**(最后的) line covers the **case** of an **invalid**(无效的) **grade**. You **should** always be **sure**(确信) that your code **cover**s such **possibilities**(可能性). 

A problem **arise**s(出现) with **nested** `if` statements when one of the `if` statements has no `else` **clause**(字句). The following **segment**s(片段) **illustrate**(举例说明) the problem.

A:    if (p)
         if (q)
            System.out.println("Path A-1");
         else
            System.out.println("Path A-2");
 
B:    if (p)
         if (q)
            System.out.println("Path B-1");
         else
            System.out.println("Path B-2"); 
The indentation in segment A indicates that the else clause is associated with the second if. The indentation in segment B indicates that the else clause is associated with the first if. Since indentation is ignored by the computer, the two segments have the same structure. The problem of deciding which interpretation is correct is called the dangling else problem. In Java, interpretation A is the correct one. The general rule is to associate an else with the nearest available preceding if. If we want to have the else associated with the first if, the preferred solution is to use brace brackets to "close off" the second if as shown in the next segment.

B*:if (p)
   {
      if (q)
         System.out.println("Path 1");
   }
   else
      System.out.println ("Path 2"); 
An empty statement provides an alternative solution to the problem.

B**: if (p)
       if (q)
         System.out.println("Path 1");
      else
         ; // to "close off" the second if
      else
         System.out.println("Path 2");
 
Exercise 3.5
Simplify the following sequence by nesting so that the effect is the same but fewer comparisons are required.
if (temperature > maxTemp)
   System.out.println("Porridge too hot");
if (temperature < minTemp)
   System.out.println("Porridge too cold");
if (temperature >= minTemp && temperature <= maxTemp)
   System.out.println("Porridge just right!"); 
Consider the following statement.
  if (age < minAge)
      if (income > minIncome)
         System.out.println("Accept");
      else
         System.out.println("Reject"); 
What will the statement print if

age > minAge and income < minIncome?
age < minAge and income < minIncome?
Using nested if statements, write a single statement that prints the smallest value contained in the variables a, b, and c.
Write a statement that, if the value of the variable item is negative, adds its value to negativeSum but, if it is positive, adds its value to positiveSum. If, on the other hand, the value of item is zero, the statement should simply increase the variable zeroCount by one.
5.      Assume that the following declarations have been made.

   int year;
   boolean isLeapYear; 
Write a fragment that will assign isLeapYear the value true if year represents a leap year and false otherwise. A year is usually a leap year if its number is a multiple of four. It is not a leap year, however, if its number is a multiple of 100 but not a multiple of 400. (As examples, 1900 was not a leap year but 2000 was a leap year.)